/**
 * Kraken Trading Proxy Server
 * Handles CORS issues by proxying requests to Kraken APIs
 */

const http = require('http');
const https = require('https');
const fs = require('fs');
const path = require('path');
const url = require('url');
const { spawn } = require('child_process');

const PORT = 8000;

// Global bot process tracking
let botProcess = null;
let botStatus = {
    running: false,
    mode: 'paper',
    pairs_scanned: 0,
    trades_completed: 0,
    current_pnl: 0.0,
    last_update: Date.now(),
    message: 'Bot not started'
};

// Learning data tracking - Enhanced
let learningData = {
    total_trades: 0,
    winning_trades: 0,
    losing_trades: 0,
    win_rate: 0.0,
    total_pnl: 0.0,
    profit_factor: 1.0,
    position_size: 100.0,
    avg_win: 0.0,
    avg_loss: 0.0,
    best_trade: 0.0,
    worst_trade: 0.0,
    max_drawdown: 0.0,
    tp_exits: 0,
    sl_exits: 0,
    trailing_exits: 0,
    timeout_exits: 0,
    blacklisted_pairs: 0,
    recent_trades: [],
    pair_stats: {},
    last_update: Date.now()
};

// MIME types for static files
const MIME_TYPES = {
    '.html': 'text/html',
    '.css': 'text/css',
    '.js': 'application/javascript',
    '.json': 'application/json',
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.svg': 'image/svg+xml',
    '.ico': 'image/x-icon'
};

// Kraken API endpoints
const KRAKEN_API_BASE = 'https://api.kraken.com/0';

/**
 * Make HTTPS request and return promise
 */
function httpsGet(targetUrl) {
    return new Promise((resolve, reject) => {
        const parsedUrl = new URL(targetUrl);

        const options = {
            hostname: parsedUrl.hostname,
            port: 443,
            path: parsedUrl.pathname + parsedUrl.search,
            method: 'GET',
            headers: {
                'User-Agent': 'KrakenTrader/1.0',
                'Accept': 'application/json'
            }
        };

        const req = https.request(options, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                resolve({
                    statusCode: res.statusCode,
                    headers: res.headers,
                    body: data
                });
            });
        });

        req.on('error', reject);
        req.setTimeout(10000, () => {
            req.destroy();
            reject(new Error('Request timeout'));
        });
        req.end();
    });
}

/**
 * Serve static files
 */
function serveStatic(req, res, filePath) {
    const ext = path.extname(filePath);
    const contentType = MIME_TYPES[ext] || 'application/octet-stream';

    fs.readFile(filePath, (err, data) => {
        if (err) {
            if (err.code === 'ENOENT') {
                res.writeHead(404);
                res.end('File not found');
            } else {
                res.writeHead(500);
                res.end('Server error');
            }
            return;
        }
        res.writeHead(200, { 'Content-Type': contentType });
        res.end(data);
    });
}

/**
 * Handle API proxy requests
 */
async function handleProxy(req, res, endpoint) {
    // Set CORS headers
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

    if (req.method === 'OPTIONS') {
        res.writeHead(204);
        res.end();
        return;
    }

    try {
        const result = await httpsGet(endpoint);
        res.writeHead(result.statusCode, {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
        });
        res.end(result.body);
    } catch (error) {
        console.error('Proxy error:', error.message);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
    }
}

/**
 * Main request handler
 */
const server = http.createServer(async (req, res) => {
    try {
        const parsedUrl = new URL(req.url, `http://localhost:8000`);
        const pathname = parsedUrl.pathname;

        console.log(`${new Date().toISOString()} ${req.method} ${pathname}`);

        // API Proxy routes
        if (pathname.startsWith('/api/')) {
            const apiPath = pathname.replace('/api/', '');

            // Asset pairs (markets)
            if (apiPath === 'assetpairs' || apiPath.startsWith('assetpairs?')) {
                const query = parsedUrl.search || '';
                await handleProxy(req, res, `${KRAKEN_API_BASE}/public/AssetPairs${query}`);
                return;
            }

            // Markets endpoint (frontend expects this format)
            if (apiPath === 'markets' || apiPath.startsWith('markets?')) {
                const limit = parsedUrl.searchParams.get('limit') || 100;
                const assetPairsResponse = await httpsGet(`${KRAKEN_API_BASE}/public/AssetPairs`);
                const data = JSON.parse(assetPairsResponse.body);
                
                if (!data.result) {
                    res.writeHead(500, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ error: 'Invalid Kraken API response' }));
                    return;
                }

                // Convert Kraken asset pairs to frontend market format
                const markets = Object.entries(data.result)
                    .filter(([pair, info]) => info.status === 'online' && pair.endsWith('USD'))
                    .slice(0, parseInt(limit))
                    .map(([pair, info]) => ({
                        id: pair,
                        pair: pair,
                        altname: info.altname,
                        wsname: info.wsname,
                        base: info.base,
                        quote: info.quote,
                        fees: parseFloat(info.fees[0][1]),
                        min_order: info.ordermin,
                        active: true,
                        market_slug: pair.toLowerCase(),
                        question: `${info.base}/${info.quote} Trading Pair`,
                        description: `Trade ${info.base} against ${info.quote} on Kraken`,
                        end_date_iso: null,
                        end_date: null,
                        active_override: true
                    }));

                res.writeHead(200, {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                });
                res.end(JSON.stringify({ markets: markets }));
                return;
            }

            // Ticker data
            if (apiPath.startsWith('ticker/')) {
                const pair = apiPath.replace('ticker/', '');
                console.log(`Fetching ticker for pair: ${pair}`);
                await handleProxy(req, res, `${KRAKEN_API_BASE}/public/Ticker?pair=${pair}`);
                return;
            }

        // Order book (depth)
        if (apiPath.startsWith('depth/')) {
            const pair = apiPath.replace('depth/', '');
            const count = parsedUrl.searchParams.get('count') || 10;
            await handleProxy(req, res, `${KRAKEN_API_BASE}/public/Depth?pair=${pair}&count=${count}`);
            return;
        }

        // Recent trades
        if (apiPath.startsWith('trades/')) {
            const pair = apiPath.replace('trades/', '');
            const since = parsedUrl.searchParams.get('since') || '';
            await handleProxy(req, res, `${KRAKEN_API_BASE}/public/Trades?pair=${pair}${since ? `&since=${since}` : ''}`);
            return;
        }
        
        // OHLC data
        if (apiPath.startsWith('ohlc/')) {
            const pair = apiPath.replace('ohlc/', '');
            const interval = parsedUrl.searchParams.get('interval') || 1;
            const since = parsedUrl.searchParams.get('since') || '';
            await handleProxy(req, res, `${KRAKEN_API_BASE}/public/OHLC?pair=${pair}&interval=${interval}${since ? `&since=${since}` : ''}`);
            return;
        }        // Server time
        if (apiPath === 'time') {
            await handleProxy(req, res, `${KRAKEN_API_BASE}/public/Time`);
            return;
        }

        // System status
        if (apiPath === 'status') {
            await handleProxy(req, res, `${KRAKEN_API_BASE}/public/SystemStatus`);
            return;
        }

        // Bot status endpoint
        if (apiPath === 'bot/status') {
            botStatus.last_update = Date.now();
            res.writeHead(200, {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            });
            res.end(JSON.stringify(botStatus));
            return;
        }

        // Bot learning data endpoint
        if (apiPath === 'bot/learning') {
            learningData.last_update = Date.now();
            res.writeHead(200, {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            });
            res.end(JSON.stringify(learningData));
            return;
        }

        // Start bot endpoint
        if (apiPath === 'bot/start') {
            if (botProcess && !botProcess.killed) {
                res.writeHead(400, {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                });
                res.end(JSON.stringify({ error: 'Bot is already running' }));
                return;
            }

            try {
                // Start the bot process
                const botPath = path.join(__dirname, 'bot', 'build', 'kraken_bot');
                botProcess = spawn(botPath, [], {
                    cwd: path.join(__dirname, 'bot', 'build'),
                    stdio: ['ignore', 'pipe', 'pipe']
                });

                botStatus = {
                    running: true,
                    mode: 'paper',
                    pairs_scanned: 0,
                    trades_completed: 0,
                    current_pnl: 0.0,
                    last_update: Date.now(),
                    message: 'Bot starting...'
                };

                // Handle bot process events
                botProcess.on('exit', (code) => {
                    console.log(`Bot process exited with code ${code}`);
                    botStatus = {
                        running: false,
                        mode: 'unknown',
                        pairs_scanned: 0,
                        trades_completed: 0,
                        current_pnl: 0.0,
                        last_update: Date.now(),
                        message: `Bot stopped (exit code: ${code})`
                    };
                    botProcess = null;
                });

                botProcess.on('error', (error) => {
                    console.error('Bot process error:', error);
                    botStatus.message = `Bot error: ${error.message}`;
                });

                // Monitor bot output for status updates - IMPROVED PARSING
                botProcess.stdout.on('data', (data) => {
                    const output = data.toString();
                    console.log('[BOT]', output.trim());
                    
                    // Parse pairs count
                    const pairsMatch = output.match(/Found (\d+) USD pairs/);
                    if (pairsMatch) {
                        botStatus.pairs_scanned = parseInt(pairsMatch[1]);
                        botStatus.message = `Scanning ${pairsMatch[1]} USD pairs`;
                    }
                    
                    if (output.includes('Scanning')) {
                        botStatus.message = 'Scanning for opportunities';
                    }
                    
                    // Parse trade result - NEW FORMAT
                    // Net P&L: $1.50 ✅ or Net P&L: $-0.40 ❌
                    const netPnlMatch = output.match(/Net P&L: \$([\-\d.]+)/);
                    if (netPnlMatch) {
                        const tradePnl = parseFloat(netPnlMatch[1]);
                        if (!isNaN(tradePnl) && Math.abs(tradePnl) < 10000) { // Sanity check
                            botStatus.trades_completed++;
                            if (tradePnl > 0) {
                                learningData.winning_trades++;
                                learningData.avg_win = ((learningData.avg_win * (learningData.winning_trades - 1)) + tradePnl) / learningData.winning_trades;
                                if (tradePnl > learningData.best_trade) learningData.best_trade = tradePnl;
                            } else {
                                learningData.losing_trades++;
                                learningData.avg_loss = ((learningData.avg_loss * (learningData.losing_trades - 1)) + tradePnl) / learningData.losing_trades;
                                if (tradePnl < learningData.worst_trade) learningData.worst_trade = tradePnl;
                            }
                        }
                    }
                    
                    // Parse exit reason
                    const exitMatch = output.match(/Exit Reason: (take_profit|stop_loss|trailing_stop|timeout)/);
                    if (exitMatch) {
                        const reason = exitMatch[1];
                        if (reason === 'take_profit') learningData.tp_exits++;
                        else if (reason === 'stop_loss') learningData.sl_exits++;
                        else if (reason === 'trailing_stop') learningData.trailing_exits++;
                        else learningData.timeout_exits++;
                    }
                    
                    // Parse trade entry with pair
                    const tradeEntryMatch = output.match(/� TRADE: (\w+) (LONG|SHORT)/);
                    if (tradeEntryMatch) {
                        const pair = tradeEntryMatch[1];
                        const direction = tradeEntryMatch[2];
                        learningData.recent_trades.unshift({
                            pair: pair,
                            direction: direction,
                            timestamp: Date.now(),
                            status: 'pending'
                        });
                        if (learningData.recent_trades.length > 30) {
                            learningData.recent_trades.pop();
                        }
                    }
                    
                    // Parse result update to finalize trade
                    const resultMatch = output.match(/Result: (take_profit|stop_loss|trailing_stop|timeout)/);
                    if (resultMatch && learningData.recent_trades.length > 0) {
                        const lastTrade = learningData.recent_trades[0];
                        if (lastTrade.status === 'pending') {
                            lastTrade.result = resultMatch[1];
                            lastTrade.status = 'completed';
                        }
                    }

                    // Parse learning summary stats
                    // Format: Trades: 10 | WR: 40.0% | P&L: $-2.50
                    const statsMatch = output.match(/Trades: (\d+) \| WR: ([\d.]+)% \| P&L: \$([\-\d.]+)/);
                    if (statsMatch) {
                        learningData.total_trades = parseInt(statsMatch[1]);
                        learningData.win_rate = parseFloat(statsMatch[2]);
                        const pnl = parseFloat(statsMatch[3]);
                        if (!isNaN(pnl) && Math.abs(pnl) < 100000) { // Sanity check
                            learningData.total_pnl = pnl;
                            botStatus.current_pnl = pnl;
                        }
                    }
                    
                    // Also parse standalone updates
                    const tradesMatch = output.match(/Total Trades: (\d+)/);
                    if (tradesMatch) {
                        learningData.total_trades = parseInt(tradesMatch[1]);
                    }
                    
                    const wrMatch = output.match(/Win Rate: ([\d.]+)%/);
                    if (wrMatch) {
                        learningData.win_rate = parseFloat(wrMatch[1]);
                    }
                    
                    // Parse P&L - with sanity check
                    const pnlMatch = output.match(/Total P&L: \$([\-\d.]+)/);
                    if (pnlMatch) {
                        const pnl = parseFloat(pnlMatch[1]);
                        // Sanity check: P&L should be reasonable
                        if (!isNaN(pnl) && Math.abs(pnl) < 100000) {
                            learningData.total_pnl = pnl;
                            botStatus.current_pnl = pnl;
                        }
                    }
                    
                    // Parse profit factor
                    const pfMatch = output.match(/PF: ([\d.]+)/);
                    if (pfMatch) {
                        learningData.profit_factor = parseFloat(pfMatch[1]);
                    }
                    
                    // Parse blacklisted count
                    const blacklistMatch = output.match(/Blacklisted: (\d+)/);
                    if (blacklistMatch) {
                        learningData.blacklisted_pairs = parseInt(blacklistMatch[1]);
                    }
                    
                    // Update timestamp
                    learningData.last_update = Date.now();
                    botStatus.last_update = Date.now();
                });

                res.writeHead(200, {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                });
                res.end(JSON.stringify({ success: true, message: 'Bot started' }));

            } catch (error) {
                console.error('Failed to start bot:', error);
                res.writeHead(500, {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                });
                res.end(JSON.stringify({ error: 'Failed to start bot process' }));
            }
            return;
        }

        // Stop bot endpoint
        if (apiPath === 'bot/stop') {
            if (!botProcess || botProcess.killed) {
                res.writeHead(400, {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                });
                res.end(JSON.stringify({ error: 'Bot is not running' }));
                return;
            }

            try {
                botProcess.kill('SIGTERM');
                
                // Give it a moment to clean up
                setTimeout(() => {
                    if (botProcess && !botProcess.killed) {
                        botProcess.kill('SIGKILL');
                    }
                }, 5000);

                botStatus = {
                    running: false,
                    mode: 'unknown',
                    pairs_scanned: 0,
                    trades_completed: 0,
                    current_pnl: 0.0,
                    last_update: Date.now(),
                    message: 'Bot stopping...'
                };

                res.writeHead(200, {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                });
                res.end(JSON.stringify({ success: true, message: 'Bot stop signal sent' }));

            } catch (error) {
                console.error('Failed to stop bot:', error);
                res.writeHead(500, {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                });
                res.end(JSON.stringify({ error: 'Failed to stop bot process' }));
            }
            return;
        }

        // Bot control endpoints
        if (apiPath === 'bot/start') {
            try {
                const { spawn } = require('child_process');
                const botPath = path.join(__dirname, 'bot', 'build', 'kraken_bot');
                
                // Check if bot is already running
                const statusFile = path.join(__dirname, 'bot_status.json');
                if (fs.existsSync(statusFile)) {
                    try {
                        const statusData = fs.readFileSync(statusFile, 'utf8');
                        const parsedStatus = JSON.parse(statusData);
                        if (parsedStatus.running) {
                            res.writeHead(400, { 'Content-Type': 'application/json' });
                            res.end(JSON.stringify({ error: 'Bot is already running' }));
                            return;
                        }
                    } catch (e) {
                        // Status file corrupted, continue
                    }
                }

                // Start the bot process
                const botProcess = spawn(botPath, [], {
                    cwd: path.join(__dirname, 'bot', 'build'),
                    detached: true,
                    stdio: 'ignore'
                });

                botProcess.unref();

                res.writeHead(200, {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                });
                res.end(JSON.stringify({ success: true, message: 'Bot started successfully' }));
            } catch (error) {
                console.error('Failed to start bot:', error);
                res.writeHead(500, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ error: 'Failed to start bot: ' + error.message }));
            }
            return;
        }

        if (apiPath === 'bot/stop') {
            try {
                const { exec } = require('child_process');
                
                // Kill any running kraken_bot processes
                exec('pkill -f kraken_bot', (error, stdout, stderr) => {
                    // Clear the status file
                    const statusFile = path.join(__dirname, 'bot_status.json');
                    try {
                        const stoppedStatus = {
                            running: false,
                            mode: 'unknown',
                            pairs_scanned: 0,
                            trades_completed: 0,
                            current_pnl: 0.0,
                            last_update: Date.now(),
                            message: 'Bot stopped'
                        };
                        fs.writeFileSync(statusFile, JSON.stringify(stoppedStatus, null, 2));
                    } catch (e) {
                        console.error('Failed to write stopped status:', e);
                    }

                    res.writeHead(200, {
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    });
                    res.end(JSON.stringify({ success: true, message: 'Bot stop requested' }));
                });
            } catch (error) {
                console.error('Failed to stop bot:', error);
                res.writeHead(500, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ error: 'Failed to stop bot: ' + error.message }));
            }
            return;
        }

        // Unknown API route
        res.writeHead(404, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Unknown API endpoint' }));
        return;
    }

    // Static file serving
    let filePath = pathname === '/' ? '/index.html' : pathname;
    filePath = path.join(__dirname, filePath);

    // Security: prevent directory traversal
    if (!filePath.startsWith(__dirname)) {
        res.writeHead(403);
        res.end('Forbidden');
        return;
    }

    serveStatic(req, res, filePath);
    } catch (error) {
        console.error('Request handler error:', error);
        res.writeHead(500, { 'Content-Type': 'text/plain' });
        res.end('Internal server error');
    }
});

// Start server
server.listen(PORT, () => {
    console.log(`
╔════════════════════════════════════════════════════════════╗
║         Kraken Trading Server v1.0                     ║
║         http://localhost:${PORT}                              ║
╠════════════════════════════════════════════════════════════╣
║  API Endpoints:                                            ║
║    /api/assetpairs     - Get trading pairs                 ║
║    /api/markets        - Get markets (frontend format)     ║
║    /api/ticker/{pair}  - Get ticker data                   ║
║    /api/depth/{pair}   - Get order book                    ║
║    /api/trades/{pair}  - Get recent trades                 ║
║    /api/ohlc/{pair}    - Get OHLC data                     ║
║    /api/time          - Get server time                    ║
║    /api/status        - Get system status                  ║
║    /api/bot/status    - Get bot status                     ║
║    /api/bot/start     - Start bot process                  ║
║    /api/bot/stop      - Stop bot process                   ║
║    /api/bot/start     - Start the bot                      ║
║    /api/bot/stop      - Stop the bot                       ║
╠════════════════════════════════════════════════════════════╣
║  Real-time prices via Kraken WebSocket                     ║
╚════════════════════════════════════════════════════════════╝
`);
});

// Handle graceful shutdown
process.on('SIGINT', () => {
    console.log('\nShutting down server...');
    server.close(() => {
        console.log('Server closed');
        process.exit(0);
    });
});
